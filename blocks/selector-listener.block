<script>
/** Under Apache 2 License from https://github.com/csuwildcat/SelectorListener **/
(function(){
	
	var events = {},
		selectors = {},
		styles = document.createElement('style'),
		keyframes = document.createElement('style'),
		head = document.getElementsByTagName('head')[0],
		startNames = ['animationstart', 'oAnimationStart', 'MSAnimationStart', 'webkitAnimationStart'],
		startEvent = function(event){
			event.selector = (events[event.animationName] || {}).selector;
			var removeList = [];
			((this.selectorListeners || {})[event.animationName] || []).forEach(function(fn){
				if (fn.call(this, event) === false) removeList.push(fn);
			}, this);
			removeList.forEach(function(fn) {
				this.removeSelectorListener(event.selector, fn);	
			}, this);
		},
		prefix = (function() {
			var duration = 'animation-duration: 0.001s;',
				name = 'animation-name: SelectorListener !important;',
				visibility = 'visibility:hidden;',
				computed = window.getComputedStyle(document.documentElement, ''),
				pre = (Array.prototype.slice.call(computed).join('').match(/moz|webkit|ms/)||(computed.OLink===''&&['o']))[0];
			return {
				css: '-' + pre + '-',
				properties: '{' + visibility + duration + name + '-' + pre + '-' + duration + '-' + pre + '-' + name + '}',
				keyframes: !!(window.CSSKeyframesRule || window[('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1] + 'CSSKeyframesRule'])
			};
		})();
		
	styles.type = keyframes.type = "text/css";
	head.appendChild(styles);
	head.appendChild(keyframes);
	
	HTMLDocument.prototype.addSelectorListener = HTMLElement.prototype.addSelectorListener = function(selector, fn){
		var key = selectors[selector],
			listeners = this.selectorListeners = this.selectorListeners || {};
			
		if (key) events[key].count++;
		else {
			key = selectors[selector] = 'SelectorListener-' + Math.random().toString(16).substr(2, 9);
			var node = document.createTextNode('@' + (prefix.keyframes ? prefix.css : '') + 'keyframes ' + key + ' {'
				+'from { outline-color: #fff; } to { outline-color: #000; }'
			+ '}');
			keyframes.appendChild(node);
			var rule = document.createTextNode(selector + prefix.properties.replace(/SelectorListener/g, key));
			styles.appendChild(rule);
			events[key] = { count: 1, selector: selector, keyframe: node, rule: rule };
		} 
		
		if (listeners.count) listeners.count++;
		else {
			listeners.count = 1;
			startNames.forEach(function(name){
				this.addEventListener(name, startEvent, false);
			}, this);
		}
		
		(listeners[key] = listeners[key] || []).push(fn);
	};
	
	HTMLDocument.prototype.removeSelectorListener = HTMLElement.prototype.removeSelectorListener = function(selector, fn){
		var listeners = this.selectorListeners || {},
			key = selectors[selector],
			listener = listeners[key] || [],
			index = listener.indexOf(fn);
			
		if (index > -1){
			var event = events[selectors[selector]];
			event.count--;
			if (!event.count){
				styles.removeChild(event.rule);
				keyframes.removeChild(event.keyframe);
				delete events[key];
				delete selectors[selector];
			}
			
			listeners.count--;
			listener.splice(index, 1);
			if (!listeners.count) startNames.forEach(function(name){
				this.removeEventListener(name, startEvent, false);
			}, this);
		}
	};

	// Single invocation version
	HTMLDocument.prototype.onSelector = HTMLElement.prototype.onSelector = function(selector,fn) {
		this.addSelectorListener(selector, function(event) { fn(event); return false; });
	};

	// Set tweak attributes on element selector as available
	var tweaks = Static.SQUARESPACE_CONTEXT.tweakJSON, parts, key, value, selector, attr, tweakMap = {};
	for (key in tweaks) {
		parts = key.split('---');
		
		if ( parts.length > 1 ) { // only for tweaks intended to be set as attributes
			parts[0] = parts[0].replace(/--/g,' .'); // make double space into class

			if (tweaks[key] !== "") { // skip empty tweak values
				selector = '#' + parts[0]; 
				attr = parts[1]; 
				value = tweaks[key].toLowerCase().replace(/\s/g,"-");

			  tweakMap[selector] = window.tweakMap[selector] || {};
			  tweakMap[selector][attr] = value;
			}
		}
	}

	for(var selector in tweakMap) {
		document.addSelectorListener(selector, function(dataset, event) {
			console.log('adding tweaks', event.target, dataset);
			event.target.dataset = dataset;
	    event.target.style.visibility = 'visible';
	  }.bind(this, tweakMap[selector]));	
	}
				
	// to handle edge case where selector-listener has not loaded selectors before domready
	document.addEventListener("DOMContentLoaded", function(event) {
		for(var selector in tweakMap) {
			var el = document.querySelector(selector);
			if (el) el.dataset = tweakMap[selector];
		}
	});

	// dynamically inject font awesome if needed
	document.onSelector('.fa', function(event) {
		var link = document.createElement('link');
		link.setAttribute('rel', 'stylesheet');
		link.setAttribute('href', '//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css');
		document.getElementsByTagName('head')[0].appendChild(link);
	});

})();
</script>